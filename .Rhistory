as.list(it)
i1 <- iter(1:10)
nextElem(i1)
nextElem(i1)
istate <- iter(state.x77, by='row')
nextElem(istate)
nextElem(istate)
ifun <- iter(function() sample(0:9, 4, replace=TRUE))
nextElem(ifun)
nextElem(ifun)
itrn <- irnorm(10)
nextElem(itrn)
nextElem(itrn)
itru <- irunif(10)
nextElem(itru)
nextElem(itru)
it <- icount(3)
nextElem(it)
nextElem(it)
nextElem(it)
rm(list = ls())
library(iterators)
it <- iter(list(1:2, 3:4))
nextElem(it)
nextElem(it)
tryCatch(nextElem(it), error=function(e) e)
iterators:::iter.iter
iterators:::nextElem.abstractiter
iforever <- function(x) {
nextEl <- function() x
obj <- list(nextElem=nextEl)
class(obj) <- c('iforever', 'abstractiter', 'iter')
obj
}
it <- iforever(42)
nextElem(it)
nextElem(it)
unlist(as.list(it, n=6))
irep <- function(x, times) {
nextEl <- function() {
if (times > 0)
times <<- times - 1
else
stop('StopIteration')
x
}
obj <- list(nextElem=nextEl)
class(obj) <- c('irep', 'abstractiter', 'iter')
obj
}
it <- irep(7, 6)
unlist(as.list(it))
ivector <- function(x, ...) {
i <- 1
it <- idiv(length(x), ...)
nextEl <- function() {
n <- nextElem(it)
ix <- seq(i, length=n)
i <<- i + n
x[ix]
}
obj <- list(nextElem=nextEl)
class(obj) <- c('ivector', 'abstractiter', 'iter')
obj
}
it <- ivector(1:25, chunks=3)
as.list(it)
hasNext <- function(obj, ...) {
UseMethod('hasNext')
}
hasNext.ihasNext <- function(obj, ...) {
obj$hasNext()
}
ihasNext <- function(it) {
if (!is.null(it$hasNext)) return(it)
cache <- NULL
has_next <- NA
nextEl <- function() {
if (!hasNx())
stop('StopIteration', call.=FALSE)
has_next <<- NA
cache
}
hasNx <- function() {
if (!is.na(has_next)) return(has_next)
tryCatch({
cache <<- nextElem(it)
has_next <<- TRUE
},
error=function(e) {
if (identical(conditionMessage(e), 'StopIteration')) {
has_next <<- FALSE
stop(e)
}
} else {
})
has_next
}
obj <- list(nextElem=nextEl, hasNext=hasNx)
class(obj) <- c('ihasNext', 'abstractiter', 'iter')
obj
}
it <- ihasNext(icount(3))
### R code from vignette source 'writing.Rnw'
###################################################
### code chunk number 1: loadLibs
###################################################
library(iterators)
###################################################
### code chunk number 2: iterable1
###################################################
it <- iter(list(1:2, 3:4))
###################################################
### code chunk number 3: iterable2
###################################################
nextElem(it)
nextElem(it)
tryCatch(nextElem(it), error=function(e) e)
###################################################
### code chunk number 4: nextElem.abstractiter
###################################################
iterators:::iter.iter
iterators:::nextElem.abstractiter
###################################################
### code chunk number 5: iter1
###################################################
iforever <- function(x) {
nextEl <- function() x
obj <- list(nextElem=nextEl)
class(obj) <- c('iforever', 'abstractiter', 'iter')
obj
}
###################################################
### code chunk number 6: runiter1
###################################################
it <- iforever(42)
nextElem(it)
nextElem(it)
###################################################
### code chunk number 7: runiter1.part2
###################################################
unlist(as.list(it, n=6))
###################################################
### code chunk number 8: iter2
###################################################
irep <- function(x, times) {
nextEl <- function() {
if (times > 0)
times <<- times - 1
else
stop('StopIteration')
x
}
obj <- list(nextElem=nextEl)
class(obj) <- c('irep', 'abstractiter', 'iter')
obj
}
###################################################
### code chunk number 9: runiter2
###################################################
it <- irep(7, 6)
unlist(as.list(it))
###################################################
### code chunk number 10: iter3
###################################################
ivector <- function(x, ...) {
i <- 1
it <- idiv(length(x), ...)
nextEl <- function() {
n <- nextElem(it)
ix <- seq(i, length=n)
i <<- i + n
x[ix]
}
obj <- list(nextElem=nextEl)
class(obj) <- c('ivector', 'abstractiter', 'iter')
obj
}
###################################################
### code chunk number 11: runiter3
###################################################
it <- ivector(1:25, chunks=3)
as.list(it)
###################################################
### code chunk number 12: generichasnext
###################################################
hasNext <- function(obj, ...) {
UseMethod('hasNext')
}
###################################################
### code chunk number 13: hasnextmethod
###################################################
hasNext.ihasNext <- function(obj, ...) {
obj$hasNext()
}
ihasNext <- function(it) {
if (!is.null(it$hasNext)) return(it)
cache <- NULL
has_next <- NA
nextEl <- function() {
if (!hasNx())
stop('StopIteration', call.=FALSE)
has_next <<- NA
cache
}
hasNx <- function() {
if (!is.na(has_next)) return(has_next)
tryCatch({
cache <<- nextElem(it)
has_next <<- TRUE
},
error=function(e) {
if (identical(conditionMessage(e), 'StopIteration')) {
has_next <<- FALSE
} else {
stop(e)
}
})
has_next
}
obj <- list(nextElem=nextEl, hasNext=hasNx)
class(obj) <- c('ihasNext', 'abstractiter', 'iter')
obj
}
it <- ihasNext(icount(3))
while (hasNext(it)) {
print(nextElem(it))
}
irecycle <- function(it) {
values <- as.list(iter(it))
i <- length(values)
nextEl <- function() {
i <<- i + 1
if (i > length(values)) i <<- 1
values[[i]]
}
obj <- list(nextElem=nextEl)
class(obj) <- c('irecycle', 'abstractiter', 'iter')
obj
}
it <- irecycle(icount(3))
unlist(as.list(it, n=9))
ilimit <- function(it, times) {
it <- iter(it)
nextEl <- function() {
if (times > 0)
times <<- times - 1
else
stop('StopIteration')
nextElem(it)
}
obj <- list(nextElem=nextEl)
class(obj) <- c('ilimit', 'abstractiter', 'iter')
obj
}
irep2 <- function(x, times)
ilimit(iforever(x), times)
it <- ihasNext(irep2('foo', 3))
while (hasNext(it)) {
print(nextElem(it))
}
iterable <- 1:3
n <- 3
it <- ilimit(irecycle(iterable), n * length(iterable))
unlist(as.list(it))
rep(iterable, n)
library("doParallel", lib.loc="~/R/win-library/3.1")
vignette("gettingstartedParallel")
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
ptime
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
stime
library(doParallel}
library(doParallel)
registerDoParallel(cores=3)
foreach(i=1:3) %dopar% sqrt(i)
ptime
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
ptime
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
stime
getDoParWorkers()
mcoptions <- list(preschedule=FALSE, set.seed=FALSE)
foreach(i=1:3, .options.multicore=mcoptions) %dopar% sqrt(i)
options(cores=2)
getDoParWorkers()
options(cores=3)
getDoParWorkers()
registerDoParallel(4)
options(cores=2)
getDoParWorkers()
stopCluster(cl)
install.packages(c("ape", "arules", "arulesViz", "BH", "bit64", "caret", "chron", "CORElearn", "DEoptimR", "devtools", "diptest", "dplyr", "DSL", "e1071", "ElemStatLearn", "evaluate", "excel.link", "forecast", "foreign", "formatR", "Formula", "gdata", "ggthemes", "glmnet", "gplots", "gridExtra", "gtools", "highlight", "highr", "Hmisc", "htmlTable", "htmlwidgets", "httr", "igraph", "installr", "jsonlite", "knitcitations", "knitr", "lattice", "lava", "lme4", "lmtest", "manipulate", "mapproj", "maps", "markdown", "mclust", "mime", "mnormt", "NLP", "NLPutils", "numDeriv", "openNLP", "openNLPdata", "pander", "party", "pgmm", "plotrix", "plyr", "polspline", "prettyR", "proxy", "pryr", "psych", "qdap", "qdapDictionaries", "qdapRegex", "Quandl", "R.utils", "R6", "rattle", "Rcpp", "RcppArmadillo", "RCurl", "RefManageR", "rgl", "rmarkdown", "rms", "robustbase", "ROCR", "RODBC", "roxygen2", "rpart", "RSNNS", "rstudioapi", "sandwich", "scales", "seriation", "shiny", "shinydashboard", "sjPlot", "sp", "stringdist", "stringi", "stringr", "strucchange", "testthat", "tis", "tm", "topicmodels", "tree", "treemap", "TSP", "TTR", "vcd", "XML"))
library(foreach)
foreach(i=1:10) %do% sample(c("H", "T"), 10000, replace=TRUE)
foreach(i=1:10) %dopar% sample(c("H", "T"), 10000, replace=TRUE)
library(doParallel)
cl <- makeCluster(2)
registerDoParallel(cores = 3)
options(cores)
options()
stopImplicitCluster()
sampleVec <- sample(1:16, size = 16)
sampleOutcomes <- sample(0:1, size = 160, replace = T)
crossprod(sampleVec, sampleOutcomes)
sampleOutcomes <- matrix(sample(0:1, size = 160, replace = T), nrow = 16)
crossprod(sampleVec, sampleOutcomes)
crossprod(rep(NULL, 16), sampleOutcomes)
crossprod(rep(0, 16), sampleOutcomes)
sampleMult <- sample(1:16, size = 64, replace = T)
calcPoints <- function(rankVec){
pointVec <- as.vector(t(crossprod(rankVec, simOutcomes2)))
}
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
calcPoints(sampleVec, sampleOutcomes)
calcPoints(sampleVec, outcomeMatrix = sampleOutcomes)
x <-calcPoints(sampleVec, outcomeMatrix = sampleOutcomes)
x
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
sampleMult <- matrix(sample(1:16, size = 64, replace = T), nrow = 16)
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
is.matrix(sampleMult)
is.matrix(sampleVec)
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
if (is.matrix(sampleVec)) {
pointVec <- as.matrix(t(crossprod(rankVec, outcomeMatrix)), nrow = dim(rankVec)[1])
}
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
if (is.matrix(sampleVec)) {
pointVec <- matrix(t(crossprod(rankVec, outcomeMatrix)), nrow = dim(rankVec)[1])
} else {
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
pointVec
}
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
x <-calcPoints(sampleVec, outcomeMatrix = sampleOutcomes)
x
x <-calcPoints(sampleMult, outcomeMatrix = sampleOutcomes)
x
sampleMult
apply(sampleMult, 2, calcPoints, outcomeMatrix = sampleOutcomes)
calcPoints <- function(rankVec, outcomeMatrix = simOutcomes2){
pointVec <- as.vector(t(crossprod(rankVec, outcomeMatrix)))
}
shiny::runApp('GitHub/fs2')
setwd("D:/Documents/GitHub/wtpP")
rm(list = ls())
library(combinat)
testM <- 1
x1 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 16
testM <- 2
x2 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 120
testM <- 3
x3 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 560
testM <- 4
x4 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 1820
# 1 + 16 + 120 + 560 + 1820 = 2517
testM <- 5
x5 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 4368
testM <- 6
x6 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 8008
testM <- 7
x7 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 11440
testM <- 8
x8 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 12870
testM <- 9
x9 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 16
testM <- 10
x10 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 800
testM <- 11
x11 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 560
testM <- 12
x12 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 1820
# 1 + 16 + 120 + 560 + 1820 = 2517
testM <- 13
x13 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 4368
testM <- 14
x14 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 8008
testM <- 15
x15 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 11440
testM <- 16
x16 <- matrix(unlist(combn(1:16, m = testM)), nrow = testM) # 12870
library(foreach)
createTwinPicks <- function(xMatrix){
nCols <- dim(xMatrix)[2]
outMat <- matrix(rep(1, 16 * nCols), ncol = nCols)
foreach(j = 1:nCols, .combine = cbind) %do% {outMat[xMatrix[, j], j] <- 0}
outMat
}
countTies <- function(vec){
sum(vec == max(vec))
}
nCols <- dim(x1)[2] + dim(x2)[2] + dim(x3)[2] + dim(x4)[2] + dim(x5)[2] + dim(x6)[2] +
dim(x7)[2] + dim(x8)[2] + dim(x9)[2] + dim(x10)[2] + dim(x11)[2] + dim(x12)[2] +
dim(x13)[2] + dim(x14)[2] + dim(x15)[2] + dim(x16)[2]
comparisonPicks <- matrix(rep(1, 16 * (65536)), nrow = 16)
populateTwinPicks <- function(xMatrix){ #xMatrix <- x8
nCols <- dim(xMatrix)[2]
chooseN <- dim(xMatrix)[1]
if(chooseN > 1) {
startCol <- 2 + foreach(n = 1:(chooseN - 1), .combine = '+') %do% {choose(16, n)}
} else {
startCol <- 2
}
endCol <- startCol + choose(16, chooseN) - 1
plugMatrix <- matrix(rep(1, 16 * nCols), nrow = 16)
for(j in 1:nCols){
plugMatrix[xMatrix[, j], j] <- 0
}
comparisonPicks[, startCol:endCol] <<- plugMatrix
}
populateTwinPicks(x1)
populateTwinPicks(x2)
populateTwinPicks(x3)
populateTwinPicks(x4)
populateTwinPicks(x5)
populateTwinPicks(x6)
populateTwinPicks(x7)
populateTwinPicks(x8)
populateTwinPicks(x9)
populateTwinPicks(x10)
populateTwinPicks(x11)
populateTwinPicks(x12)
populateTwinPicks(x13)
populateTwinPicks(x14)
populateTwinPicks(x15)
populateTwinPicks(x16)
fanMatrix <- matrix(runif(16 * 1700) , nrow = 16)
lsList = ls()
rm(list = lsList[-c(1, 4)])
save.image("straightStart.RData")
weekFileOrig <- read.csv("2015week01straight.csv", stringsAsFactors = F)
weekFileOrig <- cbind(order = 1:16, weekFileOrig)
weekFile <- weekFileOrig[order(-weekFileOrig$WinProbability), ]
winprob <- weekFile$WinProbability[order(-weekFile$WinProbability)]
outcomeMatrix <- matrix(runif(16 * 1700) < winprob, nrow = 16)
# outcomeMatrix[, 1:10]
comparisonPicksScores <- crossprod(outcomeMatrix, comparisonPicks) + crossprod((1- outcomeMatrix), (1 - comparisonPicks))
fanprob <- weekFile$FanProb[order(-weekFile$WinProbability)]
fanMatrix <- matrix((fanMatrix < fanprob) * 1, nrow = 16)
fanScores <- crossprod(outcomeMatrix, fanMatrix) + crossprod((1- outcomeMatrix), (1 - fanMatrix))
fanSubset <- matrix(rep(0, 1700 * 250), nrow = 1700)
sampleFans <- matrix(sample(1:1700, 1700 * 250, replace = T), nrow = 1700)
for (i in 1:1700){
fanSubset[i, ] <- fanScores[i, sampleFans[i, ]]
}
rm(fanScores)
save.image("2015wk01.RData")
poolsize <- 22
fanScoreSubset <- fanSubset[, 1:poolsize]
comparisonFirst <- comparisonPicksScores > apply(fanScoreSubset, 1, max)
comparisonTiedorFirst <- comparisonPicksScores >= apply(fanScoreSubset, 1, max)
outright <- which(colSums(comparisonFirst) == max(colSums(comparisonFirst)))
mostwins <- which(colSums(comparisonTiedorFirst) == max(colSums(comparisonTiedorFirst)))
# comparisonPicks[, outright]
# comparisonPicks[, mostwins]
colSums(comparisonFirst)[outright] +
0.5 * (colSums(comparisonTiedorFirst)[outright] -
colSums(comparisonFirst)[outright])
colSums(comparisonFirst)[mostwins] +
0.5 * (colSums(comparisonTiedorFirst)[mostwins] -
colSums(comparisonFirst)[mostwins])
sum(comparisonPicks[, mostwins] * winprob)
sum(comparisonPicks[, outright] * winprob)
colSums(comparisonTiedorFirst)[mostwins]
colSums(comparisonTiedorFirst)[outright]
colSums(comparisonFirst)[outright]
colSums(comparisonFirst)[mostwins]
comparisonPicks[,outright]
comparisonPicks[,mostwins]
pick <- comparisonPicks[,mostwins]
straightPicks <- weekFile$Victor
straightPicks[pick == 0] <- weekFile$Underdog[pick == 0]
outDF <- data.frame(Game = weekFile$Game, pick = straightPicks)
outDF[order(weekFile$order), ]
